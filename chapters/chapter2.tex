\part{数据结构和算法}

\chapter{数据结构}

\section{栈}
栈是先进后出的基本数据结构，实际上程序在递归调用时都需要使用栈，但这种情况一般由
编译器隐式完成。

\subsection{括号题目}
括号是典型的满足先进后出特点的一种结构，所以和括号相关的题目一般都可以利用栈来解
决，例如以下题目：

% LC 678. Valid Parenthesis String(min/max count)

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/}{LeetCode
      921. Minimum Add to Make Parentheses Valid}
  \item
    \href{https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/}{LeetCode
      1249. Minimum Remove to Make Valid Parentheses}
  \item
    \href{https://leetcode.com/problems/longest-valid-parentheses/}{LeetCode 32. Longest Valid Parentheses}
\end{itemize}

以下题目需要利用哈希表存储不同层级括号间的信息：

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/score-of-parentheses/}{LeetCode 856. Score of Parentheses}
  \item
    \href{https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/}{LeetCode
    1190. Reverse Substrings Between Each Pair of Parentheses}
\end{itemize}

\subsection{计算器题目}

\subsection{文本解析题目}

相关题目：

\begin{itemize}
  \item 
    \href{https://leetcode.com/problems/decode-string/}{LeetCode 394. Decode
      String}：数字、字母、左右括号分别处理，利用栈记录当前和之前的 string。
\end{itemize}

\section{队列}

\section{优先队列（堆）}
优先队列的适用场合是在插入/删除频繁的数组中获得最小值，一个典型的实现是堆。优先
队列也是在难题中应用广泛的一种数据结构。

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/design-a-leaderboard}{LeetCode 1244.
      Design A Leader board}：堆的直接应用，也可以使用快排获得前 k 大的数。
  \item
    \href{https://leetcode.com/problems/minimum-cost-to-connect-sticks}{LeetCode
      1167. Minimum Cost to Connect Sticks}：维护小顶堆。
\end{itemize}

\section{链表}

\section{哈希表}

\section{树}

\section{图}

\subsection{拓扑排序}
拓扑排序是指将一个有向无环图（Directed Acyclic Graph，DAG）G 中的所有顶点排成一个
线性序列，使得对任意一对顶点 $u, v$，若边 $(u, v) \in G$，则在序列中 $u$ 出现
在 $v$ 之前。

拓扑排序相关题目：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/course-schedule/}{LeetCode 207. Course Schedule}
  \item
    \href{https://leetcode.com/problems/course-schedule-ii/}{LeetCode 210. Course Schedule II}
  \item
    \href{https://leetcode.com/problems/parallel-courses}{LeetCode 1136. Parallel Courses(Premium)}
  \item
    \href{https://leetcode.com/problems/sequence-reconstruction}{LeetCode 444.
      Sequence Reconstruction}
  \item
    \href{https://leetcode.com/problems/alien-dictionary}{LeetCode 269. Alien Dictionary}
  \item
    \href{https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/}{LeetCode
      1203. Sort Items by Groups Respecting Dependencies}：双层拓扑排序
\end{itemize}

\section{前缀树}

\section{线段树}

\chapter{算法}
\section{遍历}
\subsection{深度优先搜索}
% LC 39. Combination Sum
深度优先搜索（Depth First Search，DFS）的应用非常广泛，基于递归的方法相当于程序
实现 DFS + 回溯，此外在树和图的遍历中也有普遍应用。

深度优先搜索 + 回溯题目：

\subsection{广度优先搜索}
广度优先搜索（Breath First Search，BFS）一般用在求最少次数/最短路径等问题中。

最少次数：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/remove-invalid-parentheses/}{LeetCode 301. Remove Invalid Parentheses}
\end{itemize}

最短路径：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/shortest-path-in-binary-matrix/}{LeetCode
      1091. Shortest Path in Binary Matrix}：八方向连通最短路径。
\end{itemize}

\subsection{最优优先搜索}
最优优先搜索是 DFS 和 BFS 的推广，一般通过维护最优堆进行搜索，在搜索时更新最优堆。
DFS 和 BFS 都可以看成是最优优先搜索的特例。相关问题：

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/swim-in-rising-water/}{LeetCode 778. Swim in Rising Water}
  \item
    \href{https://leetcode.com/problems/path-with-maximum-minimum-value}{LeetCode
      1102. Path With Maximum Minimum Value}：与 LeetCode 778 相同。
  \item
    \href{https://leetcode.com/problems/trapping-rain-water-ii/}{LeetCode 407.
      Trapping Rain Water II}：维护最小堆，依次出堆判断四方向位置并入堆。
\end{itemize}


\section{并查集}

\section{动态规划}

\subsection{一维动态规划}
% LC 91. Decode ways

\subsection{二维动态规划}
二维动态规划的一个典型场景是字符串的公共/回文子串和编辑距离问题：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/longest-common-subsequence/}{LeetCode 1143. Longest Common Subsequence}
  \item
    \href{https://leetcode.com/problems/longest-palindromic-subsequence/}{LeetCode
      516. Longest Palindromic Subsequence}：可转化为求字符串与其自身倒序的 LCS，
    即转化为 LeetCode 1143。
  \item
    \href{https://leetcode.com/problems/palindrome-removal/}{LeetCode 1246. Palindrome Removal(Premium)}
  \item
    \href{https://leetcode.com/problems/edit-distance/}{LeetCode 72. Edit Distance}
  \item
    \href{https://leetcode.com/problems/one-edit-distance}{LeetCode 161. One
      Edit Distance}：与 LeetCode 72 类似，只需要判断是否为 1。
  \item
    \href{https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/}{LeetCode
      712. Minimum ASCII Delete Sum for Two Strings}：LeetCode 72 升级版，只允许
    删除操作，同时代价变为字符的 ASCII 值。
  \item
    \href{https://leetcode.com/problems/regular-expression-matching/}{LeetCode
      10. Regular Expression Matching}：分析 s[i:] 和 t[j:] 的匹配，单独考虑字符
    为 * 的情况。
\end{itemize}

\section{贪心}
贪心可以看做一种特殊的动态规划，即局部最优解一定是全局最优解，因此贪心算法不断选
择局部最优解以构造全局最优解。

\subsection{区间选择问题}
区间选择问题是贪心算法的经典应用场景，每个区间的权重均相同时才能应用贪心算法，若
不同则需要使用动态规划求解。

\begin{itemize}
  \item 
    \href{https://leetcode.com/problems/meeting-rooms-ii}{LeetCode 253. Meeting
      Rooms II}
  \item
    \href{https://leetcode.com/problems/non-overlapping-intervals/}{LeetCode
      435. Non-overlapping Intervals}
  \item
    \href{https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/}{LeetCode
      452. Minimum Number of Arrows to Burst Balloons}
\end{itemize}

最小生成树 Kruskal 算法：
\begin{itemize}
  \item 
    \href{https://leetcode.com/problems/optimize-water-distribution-in-a-village}{LeetCode
      1168. Optimize Water Distribution in a Village}：well 可转化为 0 号节点到
    所有节点的边，然后应用 Kruskal 算法，利用并查集判断是否连通。
\end{itemize}

\section{二分查找}
二分查找的典型应用场景包括：

\begin{itemize}
  \item 在有序序列（数组、矩阵等）中查找某个值。
  \item 在一定范围内查找满足某个条件的最大/最小值。
\end{itemize}

\subsection{有序序列查找}
二分查找的基本题型：

二分查找的变形题型：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/search-in-rotated-sorted-array/}{LeetCode
      33. Search in Rotated Sorted Array}：判断 left/right 和 mid 值的关系，得到
    有序部分，判断 target 是否在有序范围，重新查找。
\end{itemize}

\subsection{范围查找}
以下题目可以直接写出二分的判断条件：

\begin{itemize}
  \label{lc:bs-range-general}
  \item
    \href{https://leetcode.com/problems/split-array-largest-sum/}{LeetCode 410. Split Array Largest Sum}
  \item
    \href{https://leetcode.com/problems/koko-eating-bananas/}{LeetCode 875. Koko Eating Bananas}
  \item
    \href{https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/}{LeetCode
      1011. Capacity To Ship Packages Within D Days}
  \item
    \href{https://leetcode.com/problems/divide-chocolate}{LeetCode 1231. Divide Chocolate}
\end{itemize}

以下题目需要结合一定的数学推导写判断条件：

\begin{itemize}
  \label{lc:bs-range-math}
  \item
    \href{https://leetcode.com/problems/nth-magical-number/}{LeetCode 878. Nth
      Magical Number}：容斥原理。
  \item
    \href{https://leetcode.com/problems/ugly-number-iii/}{LeetCode 1201. Ugly
      Number III}：LeetCode 878 升级版，两个数变为三个数。

\end{itemize}

\section{滑动窗口}

滑动窗口有时也叫双指针，一般是用 l 和 r 两个变量记录起始、结束位置，根据条件更新
结果或调整 l 和 r 的值。

两指针异向滑动，一般用于解决回文问题：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/longest-palindromic-substring/}{LeetCode
    5. Longest Palindromic Substring}
\end{itemize}

两指针同向滑动，典型问题是求满足条件的最长子串：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/longest-substring-without-repeating-characters/submissions/}{LeetCode
      3. Longest Substring Without Repeating Characters}：用 dict 记录每个字符的
    位置，遇到 dict 中存在的字符时，判断更新窗口左边界。
  \item
    \href{https://leetcode.com/problems/max-consecutive-ones-iii/}{LeetCode 1004. Max Consecutive Ones III}
  \item
    \href{https://leetcode.com/problems/longest-repeating-character-replacement/}{LeetCode
      424. Longest Repeating Character Replacement}：LeetCode 1004 升级版，0/1 变为 26 个大写字母。
  \item
    \href{https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters}{LeetCode
      159. Longest Substring with At Most Two Distinct Characters(Premium)}
  \item
    \href{https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters}{LeetCode
      340. Longest Substring with At Most K Distinct Characters(Premium)}：LeetCode 159
    升级版，2 个不同字母变为 k 个不同字母。
  \item
    \href{https://leetcode.com/problems/subarrays-with-k-different-integers}{LeetCode
    992. Subarrays with K Different Integers}：要求的是正好 k 个，可以转化为最多
  k 个 - 最多 k-1 个，类似 LeetCode 340。
  \item
    \href{https://leetcode.com/problems/get-equal-substrings-within-budget/}{LeetCode
      1208. Get Equal Substrings Within Budget}：转化为和不超过 k 的最长子数组。
  \item
    \href{https://leetcode.com/problems/minimum-size-subarray-sum/}{LeetCode
      209. Minimum Size Subarray Sum}：和不小于 k 的最短子数组。
\end{itemize}

\section{前缀和}
前缀和（Prefix Sum）可以认为是线段树的简化版，在数组不频繁更新的情况下，可以利用
前缀和在 O(1) 时间，O(n) 空间的条件下获得数组在某一范围内的和。

前缀和 + 哈希相关题目：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/subarray-sum-equals-k/}{LeetCode 560. Subarray Sum Equals K}
  \item
    \href{https://leetcode.com/problems/count-number-of-nice-subarrays/}{LeetCode
      1248. Count Number of Nice Subarrays}
\end{itemize}

\section{数学}

这部分题目一般都是考察数学功底，需要一定的数学基础和推导计算才能完成。

需要一定推导：
\begin{itemize}
  \item 
    \href{https://leetcode.com/problems/rotate-function/}{LeetCode 396. Rotate
      Function}：前后项相减写递推关系。
\end{itemize}

对数学基础有要求的题目：

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/check-if-it-is-a-good-array/}{LeetCode
      1250. Check If It Is a Good Array}：裴蜀定理。
\end{itemize}

% 待分类
% 排列
% 31. Next Permutation
%
% DFS/BFS
% 1245. Tree Diameter
% 动态规划
% 1239. Maximum Length of a Concatenated String with Unique Characters

%%% Local Variables:
%%% TeX-master: "../master"
%%% End:
