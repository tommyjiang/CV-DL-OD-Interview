\part{数据结构和算法}

\chapter{数据结构}

\section{栈}
栈是先进后出的基本数据结构，实际上程序在递归调用时都需要使用栈，但这种情况一般由
编译器隐式完成。

\subsection{括号题目}
括号是典型的满足先进后出特点的一种结构，所以和括号相关的题目一般都可以利用栈来解
决，例如以下题目：

% LC 678. Valid Parenthesis String(min/max count)

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/}{LeetCode
      921. Minimum Add to Make Parentheses Valid}
  \item
    \href{https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/}{LeetCode
      1249. Minimum Remove to Make Valid Parentheses}
  \item
    \href{https://leetcode.com/problems/longest-valid-parentheses/}{LeetCode 32. Longest Valid Parentheses}
\end{itemize}

以下题目需要利用哈希表存储不同层级括号间的信息：

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/score-of-parentheses/}{LeetCode 856. Score of Parentheses}
  \item
    \href{https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/}{LeetCode
    1190. Reverse Substrings Between Each Pair of Parentheses}
\end{itemize}

\subsection{计算器题目}

\subsection{文本解析题目}

相关题目：

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/decode-string/}{LeetCode 394. Decode
      String}：数字、字母、左右括号分别处理，利用栈记录当前和之前的 string。
\end{itemize}

\section{队列}

\section{优先队列（堆）}
优先队列的适用场合是在插入/删除频繁的数组中获得最小值，一个典型的实现是堆。优先
队列也是在难题中应用广泛的一种数据结构。

\section{链表}
链表相关问题一般都需要新建一个哨兵节点（Dummy node），哨兵节点的下一节点为当前链
表头节点，以简化边界处理。

\subsection{翻转}
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/reverse-linked-list}{翻转整个链表（LC
    206）}。
  \item
    \href{https://leetcode.com/problems/reverse-linked-list-ii}{翻转部分链表（LC
    92）}。
  \item
    \href{https://leetcode.com/problems/reverse-nodes-in-k-group/}{每 k 个节点翻
      转（LC 25）}
\end{itemize}

\subsection{删除节点}
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/reverse-linked-list}{删除有重复值的节
      点，只保留第一个（LC 83）}。
  \item
    \href{https://leetcode.com/problems/reverse-linked-list-ii}{删除有重复值的
      所有节点（LC 82）}。
\end{itemize}


\section{哈希表}

\section{树}

\subsection{一般二叉树}
\paragraph{树的遍历}
树的遍历同样包括深度优先和广度优先两种，其中深度优先又包括前序（中、左、右）、中
序（左、中、右）、后序（左、右、中）三种，指的是父节点相对子节点的遍历顺序。需要
同时掌握递归和非递归两种写法。

\begin{itemize}
\item 树的 DFS 遍历：
  \href{https://leetcode.com/problems/binary-tree-preorder-traversal}
  {前序遍历（LC 144）}，
  \href{https://leetcode.com/problems/binary-tree-inorder-traversal}
  {中序遍历（LC 94）}和
  \href{https://leetcode.com/problems/binary-tree-postorder-traversal}
  {后序遍历（LC 145）}。

\item 树的 BFS 遍历：
  \href{https://leetcode.com/problems/binary-tree-postorder-traversal}
  {层次遍历（LC 102）}，相关问题
  \href{https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal}
  {LC 103}，
  \href{https://leetcode.com/problems/binary-tree-right-side-view}
  {LC 199}。

\item 根据遍历结果重构树：
  \href{https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal}
  {前序+中序重构（LC 105）}，
  \href{https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal}
  {中序+后序重构（LC 106）}，
  \href{https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal}
  {前序+后序重构（LC 889）}。
\end{itemize}

\paragraph{典型问题}
树的典型问题一般可以利用递归解决，其中参数一般与父节点及祖先相关，返回值一般与子
节点及后代相关。
\begin{itemize}
\item 最低公共祖先（Lowest Common Ancestors，LCA）问
  题：
  包括
  \href{https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree}
  {二叉树任意两节点（LC 236）}，
  \href{https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves}
  {二叉树最深节点（LC 1123）}以及
  \href{https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree}
  {BST 两节点（LC 235）}。
  如果树中节点有指向父节点的指针，则可将 LCA 问题转化为两个链表的第一个公共节点问题。
\end{itemize}

\subsection{二叉搜索树}

二叉搜索树（Binary Search Tree，BST）是一种特殊的二叉树，整棵树满足父节点大于左
子节点且小于右子节点。

\paragraph{BST 的主要 API}
\begin{itemize}
  \item 查找
    （\href{https://leetcode.com/problems/search-in-a-binary-search-tree}{LC
      700}）。
  \item 插入
    （\href{https://leetcode.com/problems/insert-into-a-binary-search-tree}{LC
      701}）。
  \item 删除（\href{https://leetcode.com/problems/delete-node-in-a-bst}{LC 450}）。
  \item 后继。包括给定根节点和值查找后继
    （\href{https://leetcode.com/problems/inorder-successor-in-bst}{LC 285}），
    和给定当前节点（带父指针）查找后继
    （\href{https://leetcode.com/problems/inorder-successor-in-bst-ii}{LC 510}）。
  \item 前驱。与后继类似。
\end{itemize}

\paragraph{BST 的遍历性质}
\begin{itemize}
\item BST 中序遍历的性质：BST 中序遍历的结果为从小到大的有序数组，利用这个性质可
  以解决
  \href{https://leetcode.com/problems/validate-binary-search-tree}
  {LC 98}，
  \href{https://leetcode.com/problems/binary-search-tree-iterator}
  {LC 173}，
  \href{https://leetcode.com/problems/kth-smallest-element-in-a-bst}
  {LC 230}。
\item BST 前序、后序性质：根据 BST 前序或后序遍历结果可以直接重构 BST，
  \href{https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal}
  {根据前序遍历结果重构 BST（LC 1008）}，LC 上暂时还没有根据后序遍历结果重构 BST
  的题目。
\end{itemize}

\section{图}

\subsection{拓扑排序}
拓扑排序是指将一个有向无环图（Directed Acyclic Graph，DAG）G 中的所有顶点排成一个
线性序列，使得对任意一对顶点 $u, v$，若边 $(u, v) \in G$，则在序列中 $u$ 出现
在 $v$ 之前。相关题目包括
\href{https://leetcode.com/problems/course-schedule/}{LC 207}，
\href{https://leetcode.com/problems/course-schedule-ii/}{LC 210}，
\href{https://leetcode.com/problems/parallel-courses}{LC 1136}，
\href{https://leetcode.com/problems/sequence-reconstruction}{LC 444}，
\href{https://leetcode.com/problems/alien-dictionary}{LC 269}，
\href{https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/}{LC 1203}。

\subsection{并查集}
并查集（Union Find，UF）可以解决图的动态连通性问题，这类问题也可以用深度优先搜索
（DFS）解决。并查集的 API 主要包括查找，判断连通性和合并，典型问题：

\begin{itemize}
  \item 
    \href{https://leetcode.com/problems/friend-circles}{图的连通分量数（LC 547）}
  \item
    \href{https://leetcode.com/problems/redundant-connection}{删除一条边使图变树
      （LC 684）}
\end{itemize}

\section{前缀树}

\chapter{算法}
\section{遍历}
\subsection{深度优先搜索}
% LC 39. Combination Sum
深度优先搜索（Depth First Search，DFS）的应用非常广泛，基于递归的方法相当于程序
实现 DFS + 回溯，此外在树和图的遍历中也有普遍应用。

深度优先搜索 + 回溯题目：

\subsection{广度优先搜索}
广度优先搜索（Breath First Search，BFS）一般用在求最少次数/最短路径等问题中。

最少次数：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/remove-invalid-parentheses/}{LeetCode 301. Remove Invalid Parentheses}
\end{itemize}

最短路径：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/shortest-path-in-binary-matrix/}{LeetCode
      1091. Shortest Path in Binary Matrix}：八方向连通最短路径。
\end{itemize}

\subsection{最优优先搜索}
最优优先搜索是 DFS 和 BFS 的推广，一般通过维护最优堆进行搜索，在搜索时更新最优堆。
DFS 和 BFS 都可以看成是最优优先搜索的特例。相关问题：

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/swim-in-rising-water/}{LeetCode 778. Swim in Rising Water}
  \item
    \href{https://leetcode.com/problems/path-with-maximum-minimum-value}{LeetCode
      1102. Path With Maximum Minimum Value}：与 LeetCode 778 相同。
  \item
    \href{https://leetcode.com/problems/trapping-rain-water-ii/}{LeetCode 407.
      Trapping Rain Water II}：维护最小堆，依次出堆判断四方向位置并入堆。
\end{itemize}


\section{并查集}

\section{动态规划}

\subsection{一维动态规划}
% LC 91. Decode ways

\subsection{二维动态规划}
二维动态规划的一个典型场景是字符串的公共/回文子串和编辑距离问题：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/longest-common-subsequence/}{LeetCode 1143. Longest Common Subsequence}
  \item
    \href{https://leetcode.com/problems/longest-palindromic-subsequence/}{LeetCode
      516. Longest Palindromic Subsequence}：可转化为求字符串与其自身倒序的 LCS，
    即转化为 LeetCode 1143。
  \item
    \href{https://leetcode.com/problems/palindrome-removal/}{LeetCode 1246. Palindrome Removal(Premium)}
  \item
    \href{https://leetcode.com/problems/edit-distance/}{LeetCode 72. Edit Distance}
  \item
    \href{https://leetcode.com/problems/one-edit-distance}{LeetCode 161. One
      Edit Distance}：与 LeetCode 72 类似，只需要判断是否为 1。
  \item
    \href{https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/}{LeetCode
      712. Minimum ASCII Delete Sum for Two Strings}：LeetCode 72 升级版，只允许
    删除操作，同时代价变为字符的 ASCII 值。
  \item
    \href{https://leetcode.com/problems/regular-expression-matching/}{LeetCode
      10. Regular Expression Matching}：分析 s[i:] 和 t[j:] 的匹配，单独考虑字符
    为 * 的情况。
\end{itemize}

\section{贪心}
贪心可以看做一种特殊的动态规划，即局部最优解一定是全局最优解，因此贪心算法不断选
择局部最优解以构造全局最优解。

\subsection{区间选择问题}
区间选择问题是贪心算法的经典应用场景，每个区间的权重均相同时才能应用贪心算法，若
不同则需要使用动态规划求解。

\begin{itemize}
  \item
    \href{https://leetcode.com/problems/meeting-rooms-ii}{LeetCode 253. Meeting
      Rooms II}
  \item
    \href{https://leetcode.com/problems/non-overlapping-intervals/}{LeetCode
      435. Non-overlapping Intervals}
  \item
    \href{https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/}{LeetCode
      452. Minimum Number of Arrows to Burst Balloons}
\end{itemize}

最小生成树 Kruskal 算法：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/optimize-water-distribution-in-a-village}{LeetCode
      1168. Optimize Water Distribution in a Village}：well 可转化为 0 号节点到
    所有节点的边，然后应用 Kruskal 算法，利用并查集判断是否连通。
\end{itemize}

\section{二分查找}
二分查找的典型应用场景包括：

\begin{itemize}
  \item 在有序序列（数组、矩阵等）中查找某个值。
  \item 在一定范围内查找满足某个条件的最大/最小值。
\end{itemize}

\subsection{有序序列查找}
二分查找的基本题型：

二分查找的变形题型：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/search-in-rotated-sorted-array/}{LeetCode
      33. Search in Rotated Sorted Array}：判断 left/right 和 mid 值的关系，得到
    有序部分，判断 target 是否在有序范围，重新查找。
\end{itemize}

\subsection{范围查找}
以下题目可以直接写出二分的判断条件：

\begin{itemize}
  \label{lc:bs-range-general}
  \item
    \href{https://leetcode.com/problems/split-array-largest-sum/}{LeetCode 410. Split Array Largest Sum}
  \item
    \href{https://leetcode.com/problems/koko-eating-bananas/}{LeetCode 875. Koko Eating Bananas}
  \item
    \href{https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/}{LeetCode
      1011. Capacity To Ship Packages Within D Days}
  \item
    \href{https://leetcode.com/problems/divide-chocolate}{LeetCode 1231. Divide Chocolate}
\end{itemize}

以下题目需要结合一定的数学推导写判断条件：

\begin{itemize}
  \label{lc:bs-range-math}
  \item
    \href{https://leetcode.com/problems/nth-magical-number/}{LeetCode 878. Nth
      Magical Number}：容斥原理。
  \item
    \href{https://leetcode.com/problems/ugly-number-iii/}{LeetCode 1201. Ugly
      Number III}：LeetCode 878 升级版，两个数变为三个数。

\end{itemize}

\section{滑动窗口}

滑动窗口有时也叫双指针，一般是用 l 和 r 两个变量记录起始、结束位置，根据条件更新
结果或调整 l 和 r 的值。

两指针异向滑动，一般用于解决回文问题：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/longest-palindromic-substring/}{LeetCode
    5. Longest Palindromic Substring}
\end{itemize}

两指针同向滑动，典型问题是求满足条件的最长子串：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/longest-substring-without-repeating-characters/submissions/}{LeetCode
      3. Longest Substring Without Repeating Characters}
  \item
    \href{https://leetcode.com/problems/max-consecutive-ones-iii/}{LeetCode 1004. Max Consecutive Ones III}
  \item
    \href{https://leetcode.com/problems/longest-repeating-character-replacement/}{LeetCode
      424. Longest Repeating Character Replacement}：LeetCode 1004 升级版，0/1 变为 26 个大写字母。
  \item
    \href{https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters}{LeetCode
      159. Longest Substring with At Most Two Distinct Characters(Premium)}
  \item
    \href{https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters}{LeetCode
      340. Longest Substring with At Most K Distinct Characters(Premium)}：LeetCode 159
    升级版，2 个不同字母变为 k 个不同字母。
  \item
    \href{https://leetcode.com/problems/subarrays-with-k-different-integers}{LeetCode
    992. Subarrays with K Different Integers}：要求的是正好 k 个，可以转化为最多
  k 个 - 最多 k-1 个，类似 LeetCode 340。
  \item
    \href{https://leetcode.com/problems/get-equal-substrings-within-budget/}{LeetCode
      1208. Get Equal Substrings Within Budget}：和不超过 k 的最长子数组。
  \item
    \href{https://leetcode.com/problems/minimum-size-subarray-sum/}{LeetCode
      209. Minimum Size Subarray Sum}：和不小于 k 的最短子数组。
\end{itemize}

\section{前缀和}
前缀和（Prefix Sum）可以认为是线段树的简化版，在数组不频繁更新的情况下，可以利用
前缀和在 O(1) 时间，O(n) 空间的条件下获得数组在某一范围内的和。

前缀和 + 哈希相关题目：
\begin{itemize}
  \item
    \href{https://leetcode.com/problems/subarray-sum-equals-k/}{LeetCode 560. Subarray Sum Equals K}
  \item
    \href{https://leetcode.com/problems/count-number-of-nice-subarrays/}{LeetCode
      1248. Count Number of Nice Subarrays}
\end{itemize}

% 待分类
% 排列
% 31. Next Permutation
%
% DFS/BFS
% 1245. Tree Diameter

%%% Local Variables:
%%% TeX-master: "../master"
%%% End:
